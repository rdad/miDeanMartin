// PPDebug.js r3 - http://github.com/rdad/PP.js
var PP=PP||{enabled:true,list:{},renderer:null,context3D:{},context2D:{},contextFinal:{},config:{camera:{z:100},rtTexture:{minFilter:THREE.LinearFilter,magFilter:THREE.NearestFilter,format:THREE.RGBFormat,stencilBuffer:false},dimension:{width:window.innerWidth,height:window.innerHeight},resolution:1},rendered:null,mouse:{enabled:false,x:0,y:0},TEXTURE:0,SHADER:1,e:null,init:function(a){a=a||{};this.config.camera.z=(a.camera_z!==undefined)?a.camera_z:this.config.camera.z;this.config.dimension=(a.dimension!==undefined)?a.dimension:this.config.dimension;this.config.resolution=(a.resolution!==undefined)?a.resolution:this.config.resolution;this.gui.enabled=(a.guiEnabled!==undefined)?a.guiEnabled:false;this.config.dimension.width*=this.config.resolution;this.config.dimension.height*=this.config.resolution;this.context2D=new PP.Context();this.contextFinal=new PP.Context({quadReverse:true});this.renderer=(a.renderer!==undefined)?a.renderer:null;this.context3D.scene=(a.scene!==undefined)?a.scene:null;this.context3D.camera=(a.camera!==undefined)?a.camera:null;if(a.clearColor!==undefined){this.renderer.setClearColorHex(a.clearColor,0)}if(this.gui.enabled&&DAT.GUI!=undefined){this.gui.handler=new DAT.GUI();this.gui.handler.close()}if(this.renderer===null||this.context3D.scene===null||this.context3D.camera===null){this.error("PP not initialized correctly: Three infos not set",true);return this}return this},setScene:function(b,a){this.context3D.scene=b;this.context3D.camera=a},addTexture:function(a,c){if(this.enabled===false){return this}var b=new PP.Texture(a,c);if(this.debug){this.debug.addSprite(b)}this.list[a]=b;this.error('Texture "'+a+'" successfully added');return this},addShader:function(a,c){if(this.enabled===false){return this}var b=new PP.Shader(a,c);if(this.guiControl){this.gui.addControl(b)}if(this.debug){this.debug.addSprite(b)}this.list[b.name]=b;this.error('Shader "'+a+'" successfully added');return this},loadShader:function(b,a,d){if(this.enabled===false){return this}if(typeof this.lib==="undefined"||typeof this.lib.shader.shaders[b]==="undefined"){this.error(["Shader '",b,"' doesn't exist in PP.lib"].join(""),true);return}var c=this.lib.shader.get(b,a,d);if(PP.gui.enabled){PP.gui.addControl(c)}if(PP.debug){PP.debug.addSprite(c)}this.list[c.name]=c;this.error('Shader "'+b+'" successfully loaded');return this},get:function(a){if(this.enabled===false){return}if(this.list[a]){return this.list[a]}else{this.error([a," doesn't exist."].join(""),true)}},start:function(){this.rendered=null},renderScene:function(){this.rendered="_scene";return this},renderTexture:function(a){if(this.enabled===false){return this}this.rendered=a;return this},renderShader:function(a){if(this.enabled===false){return this}this.rendered=a;this.e=this.list[a];if(typeof this.e==="undefined"){this.error(["Shader '",a,"' can't be found: no render"].join(""),true);return this}this.e=this.list[a];this.context2D.quad.materials=[this.e.material];if(this.e.update){this.e.update(this.e)}this.renderer.render(this.context2D.scene,this.context2D.camera,this.e.textureOut,true);return this},toTexture:function(a){if(this.enabled===false){return}if(this.rendered==="_scene"){this.renderer.render(this.context3D.scene,this.context3D.camera,this.list[a].textureOut,true)}else{if(a==this.rendered){return}var c=this.list[a],b=PP.list[this.rendered];if(c.type==PP.SHADER&&typeof c.material.uniforms.textureIn!="undefined"){c.material.uniforms.textureIn.texture=b.textureOut}}},toScene:function(){if(this.enabled===false){return}if(this.debug){this.debug.update()}this.contextFinal.quad.materials[0].map=this.list[this.rendered].textureOut;this.renderer.render(this.contextFinal.scene,this.contextFinal.camera)},error:function(b,a){if(this.debug){this.debug.toConsole(b)}if(typeof a!=undefined&&a==true){this.enabled=false;PP.debug.showConsole()}},getLastRenderedShaderName:function(){return this.rendered}};PP.Context=function(a){a=a||{};this.dimension=(typeof a.dimension=="undefined")?PP.config.dimension:a.dimension;this.scene=new THREE.Scene();this.camera=new THREE.Camera();this.camera.projectionMatrix=THREE.Matrix4.makeOrtho(this.dimension.width/-2,this.dimension.width/2,this.dimension.height/2,this.dimension.height/-2,-10000,10000);this.camera.position.z=PP.config.camera.z;this.quad=new THREE.Mesh(new THREE.PlaneGeometry(1,1),new THREE.MeshBasicMaterial());this.quad.position.z=-500;this.quad.scale.set(this.dimension.width,this.dimension.height,1);if(typeof a.quadReverse!="undefined"){this.quad.doubleSided=true;this.quad.scale.y=-this.quad.scale.y}this.scene.addObject(this.quad)};PP.gui={enabled:false,mouseControl:{enabled:false,x:0,y:0,windowHalfX:window.innerWidth/2,windowHalfY:window.innerHeight/2},handler:null};PP.gui.addControl=function(b){var e,d,a,g,f;e={};e.effectController={shaderName:function(){},effect:b};g=b.controls;e.onChange=function(c){this.object.effect.material.uniforms[this.propertyName].value=c};e.onChangeMouseControl=function(c){if(c){this.object.effect.update=function(h){h.material.uniforms.position.value.x=PP.gui.mouseControl.windowHalfX+PP.gui.mouseControl.x;h.material.uniforms.position.value.y=PP.gui.mouseControl.windowHalfY-PP.gui.mouseControl.y}}else{this.object.effect.update=undefined}};this.handler.add(e.effectController,"shaderName").name("EFFECT: "+b.name.toUpperCase());for(f in g){d=g[f];a=b.material.uniforms[f].type;switch(a){case"i":e.effectController[f]=(b.material.uniforms[f].value==1)?true:false;this.handler.add(e.effectController,f).name(f).onChange(e.onChange);break;case"v2":e.effectController[f]=false;this.enableMouseControl();this.handler.add(e.effectController,f).name(f+" (mouse control)").onChange(e.onChangeMouseControl);break;default:e.effectController[f]=b.material.uniforms[f].value;this.handler.add(e.effectController,f,d.min,d.max,d.step).onChange(e.onChange)}}b.control=e};PP.gui.enableMouseControl=function(){if(!this.mouseControl.enabled){this.mouseControl.enabled=true;document.addEventListener("mousemove",PP.gui.onDocumentMouseMove,false)}};PP.gui.onDocumentMouseMove=function(a){PP.gui.mouseControl.x=a.clientX-PP.gui.mouseControl.windowHalfX;PP.gui.mouseControl.y=a.clientY-PP.gui.mouseControl.windowHalfY};PP.Shader=function(a,b){b=b||{};this.name=a;this.type=PP.SHADER;this.cible="";var c=(typeof b.dimension!="undefined")?b.dimension:PP.config.dimension;this.material=new THREE.MeshShaderMaterial({uniforms:b.uniforms,vertexShader:b.vertexShader,fragmentShader:b.fragmentShader});this.material.blending=(b.blending)?b.blinding:THREE.NormalBlending;this.textureOut=new THREE.WebGLRenderTarget(c.width,c.height,PP.config.rtTexture);if(typeof b.value!="undefined"){this.setUniforms(b.value)}if(typeof b.attributes!="undefined"){this.setAttributes(b.attributes)}if(b.controls){this.controls=b.controls}if(b.variable){this.variable=b.variable}if(b.update){this.update=b.update}};PP.Shader.prototype.copyTo=function(a){if(a==PP.rendered){return}var b=PP.list[a];if(typeof b.textureOut!="undefined"){b.textureOut=this.textureOut}};PP.Shader.prototype.setUniforms=function(b){for(var a in b){this.set(a).toValue(b[a])}};PP.Shader.prototype.setAttributes=function(a){this.material.attributes=a};PP.Shader.prototype.set=function(a){if(this.material.uniforms[a]){this.cible=a}else{PP.error(this.name+".uniforms."+a+" doesn't exist",true)}return this};PP.Shader.prototype.get=function(a){if(this.material.uniforms[a]){return this.material.uniforms[a].value}else{PP.error(this.name+".uniforms."+a+" doesn't exist",true);return 0}};PP.Shader.prototype.toTexture=function(a){if(typeof a=="string"){var b=PP.list[a];this.material.uniforms[this.cible].texture=b.textureOut}else{this.material.uniforms[this.cible].texture=a}};PP.Shader.prototype.toValue=function(a){this.material.uniforms[this.cible].value=a};PP.Shader.prototype.toAdd=function(a){this.material.uniforms[this.cible].value+=a};PP.Shader.prototype.toSub=function(a){this.material.uniforms[this.cible].value-=a};PP.Texture=function(b,c){var a;if(typeof c==="object"){a=c}else{a={width:PP.config.dimension.width,height:PP.config.dimension.height,options:PP.config.rtTexture}}this.name=b;this.type=PP.TEXTURE;this.textureOut=new THREE.WebGLRenderTarget(a.width,a.height,a.options)};PP.Shader.prototype.copyTo=function(a){if(a==this.rendered){return}var b=PP.list[this.rendered];if(typeof b.textureOut!="undefined"){this.textureOut=b.textureOut.clone()}};PP.lib=PP.lib||{vextexShaderBase:["varying vec2 vUv;","void main() {","vUv = vec2( uv.x, 1.0 - uv.y );","gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"]};PP.lib.shader={shaders:{},get:function(d,b,f){var a,e,c;if(f!=undefined){if(f.part!=undefined){c=f.part}}if(c==undefined){e=this.shaders[d];e.uniforms=THREE.UniformsUtils.clone(this.shaders[d].uniforms);if(typeof b!="undefined"){e.value=b}a=new PP.Shader(d,e)}else{a=(c=="uniforms")?THREE.UniformsUtils.clone(this.shaders[d].uniforms):this.shaders[d][c]}return a}};PP.lib.material={get:function(a){var b;b=PP.lib.shader.shaders[a];b.uniforms=THREE.UniformsUtils.clone(this.shaders[a].uniforms);return new THREE.MeshShaderMaterial(b)}};PP.lib.shader.shaders.depthLinear={info:{name:"Linear Depth buffer",author:"@Geeks3D",link:"http://www.geeks3d.com/20091216/geexlab-how-to-visualize-the-depth-buffer-in-glsl/"},uniforms:{textureIn:{type:"t",value:0,texture:null},cameraNear:{type:"f",value:1},cameraFar:{type:"f",value:100}},controls:{cameraNear:{min:0,max:1000,step:1},cameraFar:{min:0,max:10000,step:1}},vertexShader:PP.lib.vextexShaderBase.join("\n"),fragmentShader:["varying vec2 vUv;","uniform sampler2D textureIn;","uniform float cameraNear;","uniform float cameraFar;","float LinearizeDepth(vec2 uv){","float n = cameraNear; // camera z near","float f = cameraFar; // camera z far","float z = texture2D(textureIn, vUv).x;","return (2.0 * n) / (f + n - z * (f - n));","}","void main(){","float d = LinearizeDepth(vUv.xy);","gl_FragColor = vec4(d, d, d, 1.0);","}"].join("\n")};PP.lib.shader.shaders.treshold={info:{name:"treshold",author:"@rdad",link:"http://www.whiteflashwhitehit.com/"},uniforms:{textureIn:{type:"t",value:0,texture:null},treshold:{type:"f",value:0.001}},controls:{treshold:{min:0,max:1,step:0.001}},vertexShader:PP.lib.vextexShaderBase.join("\n"),fragmentShader:["varying vec2 vUv;","uniform float treshold;","uniform sampler2D textureIn;","void main(){","vec3 color = texture2D(textureIn, vUv).xyz;","vec3 black = vec3(0.0);","//float intensity = (color.r + color.g + color.b) / 3.0;","float intensity = max(color.r, color.g);","intensity = max(intensity,color.b);","gl_FragColor = (intensity > treshold) ? vec4(intensity, intensity, intensity,1.0) : vec4(black,1.0);","}"].join("\n")};PP.lib.shader.shaders.blend={info:{name:"blend",author:"@rdad",link:"http://www.whiteflashwhitehit.com/"},uniforms:{textureIn:{type:"t",value:0,texture:null},textureAdd:{type:"t",value:1,texture:null},opacity:{type:"f",value:1}},controls:{opacity:{min:0,max:1,step:0.001}},vertexShader:PP.lib.vextexShaderBase.join("\n"),fragmentShader:["varying vec2 vUv;","uniform sampler2D textureIn;","uniform sampler2D textureAdd;","uniform float opacity;","void main() {","//vec3 texel = texture2D( textureIn, vUv ).rgb;","//vec3 add = texture2D( textureAdd, vUv ).rgb;","//float intensity = normalize(add.r + add.g + add.b);","//float b = intensity * opacity;","//float b = add.b * opacity;","vec3 color1 = texture2D( textureIn, vUv ).rgb * opacity;","vec3 color2 = texture2D( textureAdd, vUv ).rgb * (1.0 - opacity);","vec3 color = (color1+color2) * 1.2;","gl_FragColor = vec4(color,1.0);","}"].join("\n")};PP.lib.shader.shaders.blendAdd={info:{name:"blendAdd",author:"@rdad",link:"http://www.whiteflashwhitehit.com/"},uniforms:{textureIn:{type:"t",value:0,texture:null},textureAdd:{type:"t",value:1,texture:null},opacity:{type:"f",value:0.5}},controls:{opacity:{min:0,max:1,step:0.001}},vertexShader:PP.lib.vextexShaderBase.join("\n"),fragmentShader:["varying vec2 vUv;","uniform sampler2D textureIn;","uniform sampler2D textureAdd;","uniform float opacity;","void main() {","vec3 one = texture2D( textureIn, vUv ).rgb;","vec3 add = texture2D( textureAdd, vUv ).rgb;","vec3 color = one*add;","gl_FragColor = vec4(color,1.0);","}"].join("\n")};PP.lib.shader.shaders.blendOn={info:{name:"blendRot",author:"@rdad",link:"http://www.whiteflashwhitehit.com/"},uniforms:{textureIn:{type:"t",value:0,texture:null},textureAdd:{type:"t",value:1,texture:null},opacity:{type:"f",value:1}},controls:{opacity:{min:0,max:1,step:0.001}},vertexShader:PP.lib.vextexShaderBase.join("\n"),fragmentShader:["varying vec2 vUv;","uniform sampler2D textureIn;","uniform sampler2D textureAdd;","uniform float opacity;","void main() {","vec3 texel = texture2D( textureIn, vUv ).rgb;","vec3 add = texture2D( textureAdd, vUv ).rgb;","if(texel.r>.1) texel = vec3(1.0, 1.0, 1.0);","vec3 color = texel*add;","gl_FragColor = vec4(color,1.0);","}"].join("\n")};PP.lib.shader.shaders.photoshopBlend={info:{name:"photoshop blend math",author:"Romain Dura aka Romzr",link:"http://mouaif.wordpress.com"},uniforms:{textureIn:{type:"t",value:0,texture:null},textureAdd:{type:"t",value:1,texture:null},mix:{type:"f",value:0.5},mode:{type:"f",value:0}},controls:{mix:{min:0,max:1,step:0.01},mode:{min:0,max:7,step:1}},vertexShader:PP.lib.vextexShaderBase.join("\n"),fragmentShader:["varying vec2 vUv;","uniform sampler2D textureIn;","uniform sampler2D textureAdd;","uniform float mix;","uniform float mode;","void main(){","vec4 one = texture2D(textureIn, vUv);","vec4 second = texture2D(textureAdd, vUv);","vec4 result = vec4(1.0);","if(mode==0.0){","one.a *= mix;","one.rgb *= one.a;","second.rgb *= second.a;","vec3 blended = one.rgb + ((1.0-one.a)*second.rgb);","float alpha = second.a + (1.0 -second.a)*one.a;","vec4 r = vec4(blended, alpha);","result = vec4(r.rgb/r.a, r.a);","}","if(mode==1.0){","result = one * second * mix;","}","if(mode==2.0){","result.r = 1.0 - ((1.0 - one.r)*(1.0 - (second.r*mix)));","result.g = 1.0 - ((1.0 - one.g)*(1.0 - (second.g*mix)));","result.b = 1.0 - ((1.0 - one.b)*(1.0 - (second.b*mix)));","}","if(mode==3.0){","result.r = (one.r < mix) ? (2.0 * one.r * second.r) : (1.0 - 2.0 * (1.0 - one.r) * (1.0 - second.r));","result.g = (one.g < mix) ? (2.0 * one.g * second.g) : (1.0 - 2.0 * (1.0 - one.g) * (1.0 - second.g));","result.b = (one.b < mix) ? (2.0 * one.b * second.b) : (1.0 - 2.0 * (1.0 - one.b) * (1.0 - second.b));","}","if(mode==4.0){","result = min(one + (second*mix), 1.0);","}","if(mode==5.0){","result = ((second == 1.0) ? second*mix : min(one / (1.0 - (second*mix)), 1.0));","}","if(mode==6.0){","result = ((second == 0.0) ? second : max((1.0 - ((1.0 - one*mix) / second)), 0.0));","}","if(mode==7.0){","vec4 a = ((second == 0.0) ? second : max((1.0 - ((1.0 - one*mix) / second)), 0.0));","a.a = mix;","result = one+a;","}","gl_FragColor = result;","}"].join("\n")};PP.lib.shader.shaders.fadeToColor={info:{name:"Fade to color",author:"@rdad",link:"http://www.whoteflashwhitehit.com"},uniforms:{textureIn:{type:"t",value:0,texture:null},color:{type:"c",value:new THREE.Color(16777215)},time:{type:"f",value:0},run:{type:"f",value:0}},controls:{run:{min:0,max:1,step:1}},update:function(a){a.material.uniforms.time.value+=(a.material.uniforms.run.value>0)?0.015:0},vertexShader:PP.lib.vextexShaderBase.join("\n"),fragmentShader:["varying vec2 vUv;","uniform sampler2D textureIn;","uniform vec3 color;","uniform float time;","void main(){","vec3 i = texture2D(textureIn, vUv).rgb;","gl_FragColor = vec4(i, 1.0 - time);","}"].join("\n")};PP.lib.shader.shaders.color={info:{name:"color adjustement",author:"Evan Wallace",link:"https://github.com/evanw/glfx.js"},uniforms:{textureIn:{type:"t",value:0,texture:null},brightness:{type:"f",value:0},contrast:{type:"f",value:0},hue:{type:"f",value:0},saturation:{type:"f",value:0},exposure:{type:"f",value:0},negative:{type:"i",value:0}},controls:{brightness:{min:-1,max:1,step:0.05},contrast:{min:-1,max:1,step:0.05},hue:{min:-1,max:1,step:0.05},saturation:{min:-1,max:1,step:0.05},exposure:{min:0,max:1,step:0.05},negative:{}},vertexShader:PP.lib.vextexShaderBase.join("\n"),fragmentShader:["varying vec2 vUv;","uniform sampler2D textureIn;","uniform float brightness;","uniform float contrast;","uniform float hue;","uniform float saturation;","uniform float exposure;","uniform int   negative;","const float sqrtoftwo = 1.41421356237;","void main() {","vec4 color = texture2D(textureIn, vUv);","color.rgb += brightness;","if (contrast > 0.0) {","color.rgb = (color.rgb - 0.5) / (1.0 - contrast) + 0.5;","} else {","color.rgb = (color.rgb - 0.5) * (1.0 + contrast) + 0.5;","}","/* hue adjustment, wolfram alpha: RotationTransform[angle, {1, 1, 1}][{x, y, z}] */","float angle = hue * 3.14159265;","float s = sin(angle), c = cos(angle);","vec3 weights = (vec3(2.0 * c, -sqrt(3.0) * s - c, sqrt(3.0) * s - c) + 1.0) / 3.0;","float len = length(color.rgb);","color.rgb = vec3(","dot(color.rgb, weights.xyz),","dot(color.rgb, weights.zxy),","dot(color.rgb, weights.yzx)",");","/* saturation adjustment */","float average = (color.r + color.g + color.b) / 3.0;","if (saturation > 0.0) {","color.rgb += (average - color.rgb) * (1.0 - 1.0 / (1.0 - saturation));","} else {","color.rgb += (average - color.rgb) * (-saturation);","}","if(negative == 1){","   color.rgb = 1.0 - color.rgb;","}","if(exposure > 0.0){","   color = log2(vec4(pow(exposure + sqrtoftwo, 2.0))) * color;","}","gl_FragColor = color;","}",].join("\n")};PP.lib.shader.shaders.bleach={info:{name:"Bleach",author:"Brian Chirls @bchirls",link:"https://github.com/brianchirls/Seriously.js"},uniforms:{textureIn:{type:"t",value:0,texture:null},amount:{type:"f",value:1}},controls:{amount:{min:0,max:1,step:0.1}},vertexShader:PP.lib.vextexShaderBase.join("\n"),fragmentShader:["varying vec2 vUv;","uniform sampler2D textureIn;","uniform float amount;","const vec4 one = vec4(1.0);","const vec4 two = vec4(2.0);","const vec4 lumcoeff = vec4(0.2125,0.7154,0.0721,0.0);","vec4 overlay(vec4 myInput, vec4 previousmix, vec4 amount) {","	float luminance = dot(previousmix,lumcoeff);","	float mixamount = clamp((luminance - 0.45) * 10.0, 0.0, 1.0);","	vec4 branch1 = two * previousmix * myInput;","	vec4 branch2 = one - (two * (one - previousmix) * (one - myInput));","	vec4 result = mix(branch1, branch2, vec4(mixamount) );","	return mix(previousmix, result, amount);","}","void main (void)  {","	vec4 pixel = texture2D(textureIn, vUv);","	vec4 luma = vec4(vec3(dot(pixel,lumcoeff)), pixel.a);","	gl_FragColor = overlay(luma, pixel, vec4(amount));","}"].join("\n")};PP.lib.shader.shaders.plasma={info:{name:"plasma",author:"iq",link:"http://www.iquilezles.org"},uniforms:{resolution:{type:"v2",value:new THREE.Vector2(PP.config.dimension.width,PP.config.dimension.height)},time:{type:"f",value:0},speed:{type:"f",value:0.01},saturation:{type:"f",value:1},waves:{type:"f",value:0.2},wiggle:{type:"f",value:1000},scale:{type:"f",value:1}},controls:{speed:{min:0,max:0.1,step:0.001},saturation:{min:0,max:10,step:0.01},waves:{min:0,max:0.4,step:0.0001},wiggle:{min:0,max:10000,step:1},scale:{min:0,max:10,step:0.01}},update:function(a){a.material.uniforms.time.value+=a.material.uniforms.speed.value},vertexShader:PP.lib.vextexShaderBase.join("\n"),fragmentShader:["varying vec2 vUv;","uniform float time;","uniform float saturation;","uniform vec2 resolution;","uniform float waves;","uniform float wiggle;","uniform float scale;","void main() {","float x = gl_FragCoord.x*scale;","float y = gl_FragCoord.y*scale;","float mov0 = x+y+cos(sin(time)*2.)*100.+sin(x/100.)*wiggle;","float mov1 = y / resolution.y / waves + time;","float mov2 = x / resolution.x / waves;","float r = abs(sin(mov1+time)/2.+mov2/2.-mov1-mov2+time);","float g = abs(sin(r+sin(mov0/1000.+time)+sin(y/40.+time)+sin((x+y)/100.)*3.));","float b = abs(sin(g+cos(mov1+mov2+g)+cos(mov2)+sin(x/1000.)));","vec3 plasma  = vec3(r,g,b) * saturation;","gl_FragColor = vec4( plasma ,1.0);","}"].join("\n")};PP.lib.shader.shaders.plasma2={info:{name:"plasma2",author:"mrDoob",link:"http://mrdoob.com"},uniforms:{resolution:{type:"v2",value:new THREE.Vector2(PP.config.dimension.width,PP.config.dimension.height)},time:{type:"f",value:0},speed:{type:"f",value:0.01},qteX:{type:"f",value:80},qteY:{type:"f",value:10},intensity:{type:"f",value:10},hue:{type:"f",value:0.25}},controls:{speed:{min:0,max:1,step:0.001},qteX:{min:0,max:200,step:1},qteY:{min:0,max:200,step:1},intensity:{min:0,max:50,step:0.1},hue:{min:0,max:2,step:0.001}},update:function(a){a.material.uniforms.time.value+=a.material.uniforms.speed.value},vertexShader:PP.lib.vextexShaderBase.join("\n"),fragmentShader:["uniform float time;","uniform vec2 resolution;","uniform float qteX;","uniform float qteY;","uniform float intensity;","uniform float hue;","void main() {","vec2 position = gl_FragCoord.xy / resolution.xy;","float color = 0.0;","color += sin( position.x * cos( time / 15.0 ) * qteX ) + cos( position.y * cos( time / 15.0 ) * qteY );","color += sin( position.y * sin( time / 10.0 ) * 40.0 ) + cos( position.x * sin( time / 25.0 ) * 40.0 );","color += sin( position.x * sin( time / 5.0 ) * 10.0 ) + sin( position.y * sin( time / 35.0 ) * 80.0 );","color *= sin( time / intensity ) * 0.5;","gl_FragColor = vec4( vec3( color, color * (hue*2.0), sin( color + time / (hue*12.0) ) * (hue*3.0) ), 1.0 );","}"].join("\n")};PP.lib.shader.shaders.plasma3={info:{name:"plasma 3",author:"Hakim El Hattab",link:"http://hakim.se"},uniforms:{color:{type:"c",value:new THREE.Color(9225946)},resolution:{type:"v2",value:new THREE.Vector2(PP.config.dimension.width,PP.config.dimension.height)},time:{type:"f",value:0},speed:{type:"f",value:0.05},scale:{type:"f",value:10},quantity:{type:"f",value:5},lens:{type:"f",value:2},intensity:{type:"f",value:0.5}},controls:{speed:{min:0,max:1,step:0.001},scale:{min:0,max:100,step:0.1},quantity:{min:0,max:100,step:1},lens:{min:0,max:100,step:1},intensity:{min:0,max:5,step:0.01}},update:function(a){a.material.uniforms.time.value+=a.material.uniforms.speed.value},vertexShader:PP.lib.vextexShaderBase.join("\n"),fragmentShader:["uniform float time;","uniform vec2 resolution;","uniform vec3 color;","uniform float scale;","uniform float quantity;","uniform float lens;","uniform float intensity;","void main() {","vec2 p = -1.0 + 2.0 * gl_FragCoord.xy / resolution.xy;","p = p * scale;","vec2 uv;","float a = atan(p.y,p.x);","float r = sqrt(dot(p,p));","uv.x = 2.0*a/3.1416;","uv.y = -time+ sin(7.0*r+time) + .7*cos(time+7.0*a);","float w = intensity+1.0*(sin(time+lens*r)+ 1.0*cos(time+(quantity * 2.0)*a));","gl_FragColor = vec4(color*w,1.0);","}"].join("\n")};PP.lib.shader.shaders.plasma4={info:{name:"plasma 4 (vortex)",author:"Hakim El Hattab",link:"http://hakim.se"},uniforms:{color:{type:"c",value:new THREE.Color(16732672)},resolution:{type:"v2",value:new THREE.Vector2(PP.config.dimension.width,PP.config.dimension.height)},time:{type:"f",value:0},speed:{type:"f",value:0.05},scale:{type:"f",value:20},wobble:{type:"f",value:1},ripple:{type:"f",value:5},light:{type:"f",value:2}},controls:{speed:{min:0,max:1,step:0.001},scale:{min:0,max:100,step:0.1},wobble:{min:0,max:50,step:1},ripple:{min:0,max:50,step:0.1},light:{min:1,max:50,step:1}},update:function(a){a.material.uniforms.time.value+=a.material.uniforms.speed.value},vertexShader:PP.lib.vextexShaderBase.join("\n"),fragmentShader:["uniform float time;","uniform vec2 resolution;","uniform vec3 color;","uniform float scale;","uniform float wobble;","uniform float ripple;","uniform float light;","void main() {","vec2 p = -1.0 + 2.0 * gl_FragCoord.xy / resolution.xy;","vec2 uv;","float a = atan(p.y,p.x);","float r = sqrt(dot(p,p));","float u = cos(a*(wobble * 2.0) + ripple * sin(-time + scale * r));","float intensity = sqrt(pow(abs(p.x),light) + pow(abs(p.y),light));","vec3 result =  u*intensity*color;","gl_FragColor = vec4(result,1.0);","}"].join("\n")};PP.lib.shader.shaders.plasma5={info:{name:"plasma 5",author:"Silexars",link:"http://www.silexars.com"},uniforms:{resolution:{type:"v2",value:new THREE.Vector2(PP.config.dimension.width,PP.config.dimension.height)},time:{type:"f",value:0},speed:{type:"f",value:0.01}},controls:{speed:{min:0,max:0.2,step:0.001}},update:function(a){a.material.uniforms.time.value+=a.material.uniforms.speed.value},vertexShader:PP.lib.vextexShaderBase.join("\n"),fragmentShader:["uniform vec2 resolution;","uniform float time;","void main() {","vec3 col;","float l,z=time;","for(int i=0;i<3;i++){","vec2 uv;","vec2 p=gl_FragCoord.xy/resolution.xy;","uv=p;","p-=.5;","p.x*=resolution.x/resolution.y;","z+=.07;","l=length(p);","uv+=p/l*(sin(z)+1.)*abs(sin(l*9.-z*2.));","col[i]=.01/length(abs(mod(uv,1.)-.5));","}","gl_FragColor=vec4(col/l,1.0);","}"].join("\n")};PP.lib.shader.shaders.plasmaByTexture={info:{name:"plasma by texture",author:"J3D",link:"http://www.everyday3d.com/j3d/demo/011_Plasma.html"},uniforms:{textureIn:{type:"t",value:0,texture:null},time:{type:"f",value:0},speed:{type:"f",value:0.01}},controls:{speed:{min:0,max:0.1,step:0.001}},update:function(a){a.material.uniforms.time.value+=a.material.uniforms.speed.value},vertexShader:PP.lib.vextexShaderBase.join("\n"),fragmentShader:["varying vec2 vUv;","uniform sampler2D textureIn;","uniform float time;","void main() {","vec2 ca = vec2(0.1, 0.2);","vec2 cb = vec2(0.7, 0.9);","float da = distance(vUv, ca);","float db = distance(vUv, cb);","float t = time * 0.5;","float c1 = sin(da * cos(t) * 16.0 + t * 4.0);","float c2 = cos(vUv.y * 8.0 + t);","float c3 = cos(db * 14.0) + sin(t);","float p = (c1 + c2 + c3) / 3.0;","gl_FragColor = texture2D(textureIn, vec2(p, p));","}"].join("\n")};PP.lib.shader.shaders.blurMotion={info:{name:"motion blur",author:"Inigo Quilez aka iq/rgba",link:"http://www.iquilezles.org/apps/shadertoy/"},uniforms:{textureIn:{type:"t",value:0,texture:null},resolution:{type:"v2",value:new THREE.Vector2(PP.config.dimension.width,PP.config.dimension.height)},time:{type:"f",value:0},speed:{type:"f",value:0.01}},controls:{speed:{min:0,max:0.2,step:0.0001}},variable:{delta:1},update:function(a){a.material.uniforms.time.value+=a.variable.delta*a.material.uniforms.speed.value;if(a.material.uniforms.time.value>10||a.material.uniforms.time.value<0){a.variable.delta*=-1}},vertexShader:PP.lib.vextexShaderBase.join("\n"),fragmentShader:["uniform vec2 resolution;","uniform float time;","uniform sampler2D textureIn;","vec3 deform( in vec2 p, float scale ){","vec2 uv;","float mtime = scale+time;","float a = atan(p.y,p.x);","float r = sqrt(dot(p,p));","float s = r * (1.0+0.5*cos(mtime*1.7));","uv.x = .1*mtime +.05*p.y+.05*cos(-mtime+a*3.0)/s;","uv.y = .1*mtime +.05*p.x+.05*sin(-mtime+a*3.0)/s;","float w = 0.8-0.2*cos(mtime+3.0*a);","vec3 res = texture2D(textureIn,uv).xyz*w;","return  res*res;","}","void main()","{","vec2 p = -1.0 + 2.0 * gl_FragCoord.xy / resolution.xy;","vec3 total = vec3(0.0);","float w = 0.0;","for( int i=0; i<20; i++ )","{","vec3 res = deform(p,w);","total += res;","w += 0.02;","}","total /= 20.0;","gl_FragColor = vec4( 3.0*total,1.0);","}"].join("\n")};PP.lib.shader.shaders.blurRadial={info:{name:"radial blur",author:"Inigo Quilez aka iq/rgba",link:"http://www.iquilezles.org/apps/shadertoy/"},uniforms:{textureIn:{type:"t",value:0,texture:null},resolution:{type:"v2",value:new THREE.Vector2(PP.config.dimension.width,PP.config.dimension.height)},time:{type:"f",value:0}},update:function(a){a.material.uniforms.time.value+=0.01},vertexShader:PP.lib.vextexShaderBase.join("\n"),fragmentShader:["uniform vec2 resolution;","uniform float time;","uniform sampler2D textureIn;","vec3 deform( in vec2 p ){","vec2 muv;","vec2 q = vec2( sin(1.1*time+p.x),sin(1.2*time+p.y) );","float a = atan(q.y,q.x);","float r = sqrt(dot(q,q));","muv.x = sin(0.0+1.0*time)+p.x*sqrt(r*r+1.0);","muv.y = sin(0.6+1.1*time)+p.y*sqrt(r*r+1.0);","return texture2D(textureIn,muv*.5).xyz;","}","void main()","{","vec2 p = -1.0 + 2.0 * gl_FragCoord.xy / resolution.xy;","vec2 s = p;","vec3 total = vec3(0.0);","vec2 d = (vec2(0.0,0.0)-p)/20.0;","float w = 1.0;","for( int i=0; i<20; i++ )","{","vec3 res = deform(s);","res = smoothstep(0.1,1.0,res*res);","total += w*res;","w *= .99;","s += d;","}","total /= 20.0;","float r = 1.5/(1.0+dot(p,p));","gl_FragColor = vec4( total*r,1.0);","}"].join("\n")};PP.lib.shader.shaders.blurZoom={info:{name:"zoom blur",author:"Evan Wallace",link:"https://github.com/evanw/glfx.js"},uniforms:{textureIn:{type:"t",value:0,texture:null},position:{type:"v2",value:new THREE.Vector2(PP.config.dimension.width/2,PP.config.dimension.height/2)},strength:{type:"f",value:0},resolution:{type:"v2",value:new THREE.Vector2(PP.config.dimension.width,PP.config.dimension.height)}},controls:{strength:{min:0,max:1,step:0.05},position:{}},vertexShader:PP.lib.vextexShaderBase.join("\n"),fragmentShader:["varying vec2 vUv;","uniform sampler2D textureIn;","uniform vec2 position;","uniform float strength;","uniform vec2 resolution;","float random(vec3 scale, float seed) {","return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);","}","void main() {","vec4 color = vec4(0.0);","float total = 0.0;","vec2 toCenter = position - vUv * resolution;","/* randomize the lookup values to hide the fixed number of samples */","float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);","for (float t = 0.0; t <= 40.0; t++) {","float percent = (t + offset) / 40.0;","float weight = 4.0 * (percent - percent * percent);","color += texture2D(textureIn, vUv + toCenter * percent * strength / resolution) * weight;","total += weight;","}","gl_FragColor = color / total;","}"].join("\n")};PP.lib.shader.shaders.blurTriangleX={info:{name:"triangle blur (pass 1)",author:"Evan Wallace",link:"https://github.com/evanw/glfx.js"},uniforms:{textureIn:{type:"t",value:0,texture:null},radius:{type:"f",value:0},resolutionW:{type:"f",value:PP.config.dimension.width}},controls:{radius:{min:0,max:200,step:0.05}},vertexShader:PP.lib.vextexShaderBase.join("\n"),fragmentShader:["varying vec2 vUv;","uniform sampler2D textureIn;","uniform float radius;","uniform float resolutionW;","float random(vec3 scale, float seed) {","/* use the fragment position for a different seed per-pixel */","return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);","}","void main() {","vec4 color = vec4(0.0);","float total = 0.0;","vec2 delta = vec2(radius / resolutionW, 0);","/* randomize the lookup values to hide the fixed number of samples */","float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);","for (float t = -30.0; t <= 30.0; t++) {","float percent = (t + offset - 0.5) / 30.0;","float weight = 1.0 - abs(percent);","color += texture2D(textureIn, vUv + delta * percent) * weight;","total += weight;","}","gl_FragColor = color / total;","}",].join("\n")};PP.lib.shader.shaders.blurTriangleY={info:{name:"triangle blur (pass 2)",author:"Evan Wallace",link:"https://github.com/evanw/glfx.js"},uniforms:{textureIn:{type:"t",value:0,texture:null},radius:{type:"f",value:0},resolutionH:{type:"f",value:PP.config.dimension.height}},controls:{radius:{min:0,max:200,step:0.05}},vertexShader:PP.lib.vextexShaderBase.join("\n"),fragmentShader:["varying vec2 vUv;","uniform sampler2D textureIn;","uniform float radius;","uniform float resolutionH;","float randomy(vec3 scale, float seed) {","/* use the fragment position for a different seed per-pixel */","return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);","}","void main() {","vec4 color = vec4(0.0);","float total = 0.0;","vec2 delta = vec2(0, radius / resolutionH);","/* randomize the lookup values to hide the fixed number of samples */","float offset = randomy(vec3(12.9898, 78.233, 151.7182), 0.0);","for (float t = -30.0; t <= 30.0; t++) {","float percent = (t + offset - 0.5) / 30.0;","float weight = 1.0 - abs(percent);","color += texture2D(textureIn, vUv + delta * percent) * weight;","total += weight;","}","gl_FragColor = color / total;","}",].join("\n")};PP.lib.shader.shaders.heat={info:{name:"heat",author:"@alteredq",link:"http://alteredqualia.com/"},uniforms:{textureIn:{type:"t",value:0,texture:null},resolution:{type:"v2",value:new THREE.Vector2(PP.config.dimension.width,PP.config.dimension.height)},vingeNetOffset:{type:"f",value:0.8},vingeNetDark:{type:"f",value:0.25},sampleDistance:{type:"f",value:0.94},waveFactor:{type:"f",value:0.00125}},controls:{sampleDistance:{min:0,max:4,step:0.1},waveFactor:{min:0,max:0.05,step:0.001},vingeNetOffset:{min:0,max:2,step:0.2},vingeNetDark:{min:0,max:2,step:0.2}},vertexShader:PP.lib.vextexShaderBase.join("\n"),fragmentShader:["uniform vec2 resolution;","uniform float vingeNetOffset;","uniform float vingeNetDark;","uniform float sampleDistance;","uniform float waveFactor;","uniform sampler2D textureIn;","varying vec2 vUv;","void main() {","vec4 color, org, tmp, add;","float sample_dist, f;","vec2 vin;","vec2 uv = vUv;","add += color = org = texture2D( textureIn, uv );","vin = (uv - vec2(0.5)) * vec2( 1.4 /*vingeNetOffset * 2.0*/);","sample_dist =(dot( vin, vin ) * 2.0);","f = (waveFactor * 100.0 + sample_dist) * sampleDistance * 4.0;","vec2 sampleSize = vec2(  1.0 / resolution.x, 1.0 / resolution.y ) * vec2(f);","add += tmp = texture2D( textureIn, uv + vec2(0.111964, 0.993712) * sampleSize);","if( tmp.b < color.b ) color = tmp;","add += tmp = texture2D( textureIn, uv + vec2(0.846724, 0.532032) * sampleSize);","if( tmp.b < color.b ) color = tmp;","add += tmp = texture2D( textureIn, uv + vec2(0.943883, -0.330279) * sampleSize);","if( tmp.b < color.b ) color = tmp;","add += tmp = texture2D( textureIn, uv + vec2(0.330279, -0.943883) * sampleSize);","if( tmp.b < color.b ) color = tmp;","add += tmp = texture2D( textureIn, uv + vec2(-0.532032, -0.846724) * sampleSize);","if( tmp.b < color.b ) color = tmp;","add += tmp = texture2D( textureIn, uv + vec2(-0.993712, -0.111964) * sampleSize);","if( tmp.b < color.b ) color = tmp;","add += tmp = texture2D( textureIn, uv + vec2(-0.707107, 0.707107) * sampleSize);","if( tmp.b < color.b ) color = tmp;","uv = (uv - vec2(0.5)) * vec2( vingeNetOffset );","color = color * vec4(2.0) - (add / vec4(8.0));","color = color + (add / vec4(8.0) - color) * (vec4(1.0) - vec4(sample_dist * 0.5));","gl_FragColor = vec4( mix(color.rgb * color.rgb * vec3( 0.95 ) + color.rgb, vec3( 0.0 ) - vec3( vingeNetDark ), vec3( dot( uv, uv ))), 1.0 );","}"].join("\n")};PP.lib.shader.shaders.film={info:{name:"Film",author:"AlteredQualia, Original implementation and noise algorithm by Pat 'Hawthorne' Shearon",link:"http://alteredqualia.com/"},uniforms:{textureIn:{type:"t",value:0,texture:null},amount:{type:"f",value:0.5},time:{type:"f",value:0},speed:{type:"f",value:0.01}},controls:{speed:{min:0,max:0.1,step:0.001},amount:{min:0,max:1,step:0.01}},update:function(a){a.material.uniforms.time.value+=a.material.uniforms.speed.value},vertexShader:PP.lib.vextexShaderBase.join("\n"),fragmentShader:["varying vec2 vUv;","uniform sampler2D textureIn;","uniform float amount;","uniform float time;","void main (void){","vec4 cTextureScreen = texture2D( textureIn, vUv );","float x = vUv.x * vUv.y * time *  1000.0;","x = mod( x, 13.0 ) * mod( x, 123.0 );","float dx = mod( x, 0.01 );","vec3 cResult = cTextureScreen.rgb + cTextureScreen.rgb * clamp( 0.1 + dx * 100.0, 0.0, 1.0 );","cResult = cTextureScreen.rgb + clamp( amount, 0.0,1.0 ) * ( cResult - cTextureScreen.rgb );","gl_FragColor =  vec4( cResult, cTextureScreen.a );","}"].join("\n")};PP.lib.shader.shaders.cellShading={info:{name:"Cell shading",author:"Adrien Debesson",link:"http://gamedev.dreamnoid.com/2009/03/11/cel-shading-en-glsl/"},uniforms:{textureIn:{type:"t",value:0,texture:null}},vertexShader:PP.lib.vextexShaderBase.join("\n"),fragmentShader:["uniform sampler2D textureIn;","varying vec2 vUv;","varying vec3 Normal;","uniform vec3 LightDir;","vec4 CelShading ( vec4 color ){","float Intensity = dot( LightDir , normalize(Normal) );","float factor = 1.0;","if ( Intensity < 0.5 ) factor = 0.5;","color *= vec4 ( factor, factor, factor, 1.0 );","return color;","}","void main (void){","vec4 color = texture2D( textureIn , vec2( vUv ) );","color = CelShading ( color );","gl_FragColor = color;","}"].join("\n")};PP.lib.shader.shaders.crossHatch={info:{name:"Cross hatch",author:"@gpjt",link:"http://learningwebgl.com/blog/?p=2858"},uniforms:{textureIn:{type:"t",value:0,texture:null}},vertexShader:PP.lib.vextexShaderBase.join("\n"),fragmentShader:["uniform sampler2D textureIn;","varying vec2 vUv;","void main() {","float lum = length(texture2D(textureIn, vUv.xy).rgb);","vec4 hatch = vec4(1.0);","vec4 bg    = vec4(0.0, 0.0, 0.0, 1.0);","vec4 color = bg;","if (lum < 1.00) {","if (mod(gl_FragCoord.x + gl_FragCoord.y, 10.0) == 0.0) {","color = hatch;","}","}","if (lum < 0.75) {","if (mod(gl_FragCoord.x - gl_FragCoord.y, 10.0) == 0.0) {","color = hatch;","}","}","if (lum < 0.50) {","if (mod(gl_FragCoord.x + gl_FragCoord.y - 5.0, 10.0) == 0.0) {","color = hatch;","}","}","if (lum < 0.3) {","if (mod(gl_FragCoord.x - gl_FragCoord.y - 5.0, 10.0) == 0.0) {","color = hatch;","}","}","if (lum == 0.0) {","color = bg;","}","gl_FragColor = color;","}"].join("\n")};PP.lib.shader.shaders.dotScreen={info:{name:"Dot screen",author:"@EvanUltraVegas (Evan Wallace) from webgl-filter",link:"https://github.com/evanw/glfx.js"},uniforms:{textureIn:{type:"t",value:0,texture:null},angle:{type:"f",value:0.5},size:{type:"f",value:0.75},texSize:{type:"v2",value:new THREE.Vector2(PP.config.dimension.width,PP.config.dimension.height)},useColor:{type:"int",value:0}},controls:{angle:{start:0.5,min:-1,max:1,step:0.02},size:{start:0.75,min:0,max:1,step:0.01},useColor:{start:0,min:0,max:1,step:1}},vertexShader:PP.lib.vextexShaderBase.join("\n"),fragmentShader:["uniform sampler2D textureIn;","uniform float angle;","uniform float size;","uniform vec2 texSize;","uniform int useColor;","varying vec2 vUv;","void main() {","vec3 color = texture2D(textureIn, vUv).rgb;","float s = sin(angle), c = cos(angle);","vec2 tex = vUv * texSize;","vec2 point = vec2(","c * tex.x - s * tex.y,","s * tex.x + c * tex.y",") * size;","float weight = (sin(point.x) * sin(point.y)) * 2.0;","float average = (color.r + color.g + color.b) / 3.0;","if(useColor==0){","color = vec3(average + (average - 0.6) * 4.0 + weight);","}else{","color.r = color.r + (color.r - 0.6) * 4.0 + weight;","color.g = color.g + (color.g - 0.6) * 4.0 + weight;","color.b = color.b + (color.b - 0.6) * 4.0 + weight;","}","gl_FragColor = vec4(color, 1.0);}"].join("\n")};PP.lib.shader.shaders.posterize={info:{author:"Agnius Vasiliauskas",link:"http://coding-experiments.blogspot.com"},uniforms:{textureIn:{type:"t",value:0,texture:null},gamma:{type:"f",value:0.6},numColors:{type:"f",value:8}},controls:{gamma:{min:0,max:2,step:0.1},numColors:{min:1,max:20,step:1}},vertexShader:PP.lib.vextexShaderBase.join("\n"),fragmentShader:["varying vec2 vUv;","uniform sampler2D textureIn;","uniform float gamma;","uniform float numColors;","void main(){","vec3 c = texture2D(textureIn, vUv.xy).rgb;","c = pow(c, vec3(gamma, gamma, gamma));","c = c * numColors;","c = floor(c);","c = c / numColors;","c = pow(c, vec3(1.0/gamma));","gl_FragColor = vec4(c, 1.0);","}"].join("\n")};PP.lib.shader.shaders.pixelate={info:{author:"Agnius Vasiliauskas",link:"http://coding-experiments.blogspot.com"},uniforms:{textureIn:{type:"t",value:0,texture:null},pixelX:{type:"f",value:10},pixelY:{type:"f",value:10},texSize:{type:"v2",value:new THREE.Vector2(PP.config.dimension.width,PP.config.dimension.height)}},controls:{pixelX:{min:1,max:50,step:1},pixelY:{min:1,max:50,step:1}},vertexShader:PP.lib.vextexShaderBase.join("\n"),fragmentShader:["varying vec2 vUv;","uniform sampler2D textureIn;","uniform vec2 texSize;","uniform float pixelX;","uniform float pixelY;","void main(){","vec2 uv = vUv.xy;","vec3 tc = vec3(1.0, 0.0, 0.0);","float dx = pixelX*(1./texSize.x);","float dy = pixelY*(1./texSize.y);","vec2 coord = vec2(dx*floor(uv.x/dx), dy*floor(uv.y/dy));","tc = texture2D(textureIn, coord).rgb;","gl_FragColor = vec4(tc, 1.0);","}"].join("\n")};PP.lib.shader.shaders.halfTone={uniforms:{textureIn:{type:"t",value:0,texture:null},scale:{type:"f",value:0.75},angle:{type:"f",value:0.5},center:{type:"v2",value:new THREE.Vector2(PP.config.dimension.width/2,PP.config.dimension.height/2)},texSize:{type:"v2",value:new THREE.Vector2(PP.config.dimension.width,PP.config.dimension.height)}},controls:{angle:{min:-1,max:1,step:0.02},scale:{min:0,max:1,step:0.01},center:{}},vertexShader:PP.lib.vextexShaderBase.join("\n"),fragmentShader:["varying vec2 vUv;","uniform sampler2D textureIn;","uniform vec2 center;","uniform float angle;","uniform float scale;","uniform vec2 texSize;","float pattern(float angle) {","float s = sin(angle), c = cos(angle);","vec2 tex = vUv * texSize - center;","vec2 point = vec2(","c * tex.x - s * tex.y,","s * tex.x + c * tex.y",") * scale;","return (sin(point.x) * sin(point.y)) * 4.0;","}","void main() {","vec4 color = texture2D(textureIn, vUv);","vec3 cmy = 1.0 - color.rgb;","float k = min(cmy.x, min(cmy.y, cmy.z));","cmy = (cmy - k) / (1.0 - k);","cmy = clamp(cmy * 10.0 - 3.0 + vec3(pattern(angle + 0.26179), pattern(angle + 1.30899), pattern(angle)), 0.0, 1.0);","k = clamp(k * 10.0 - 5.0 + pattern(angle + 0.78539), 0.0, 1.0);","gl_FragColor = vec4(1.0 - cmy - k, color.a);","}",].join("\n")};PP.lib.shader.shaders.simplexNoise={info:{name:"Simplex noise",author:"Ian McEwan, Ashima Arts",link:"https://github.com/ashima/webgl-noise"},uniforms:{textureIn:{type:"t",value:0,texture:null},time:{type:"f",value:0},speed:{type:"f",value:0.5},scale:{type:"f",value:0.001},bias:{type:"f",value:0.01}},controls:{speed:{min:0,max:2,step:0.01},scale:{min:0,max:0.05,step:0.0001},bias:{min:0,max:0.5,step:0.001}},update:function(a){a.material.uniforms.time.value+=this.material.uniforms.speed.value},vertexShader:["uniform float time;","uniform float scale;","varying vec3 vTexCoord3D;","varying vec2 vUv;","void main( void ) {","vTexCoord3D = scale * ( position.xyz + vec3( 0.0, 0.0, -time ) );","vUv = vec2( uv.x, 1.0 - uv.y );","gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["varying vec3 vTexCoord3D;","varying vec2 vUv;","uniform float time;","uniform sampler2D textureIn;","uniform float bias;","vec4 permute( vec4 x ) {","return mod( ( ( x * 34.0 ) + 1.0 ) * x, 289.0 );","}","vec4 taylorInvSqrt( vec4 r ) {","return 1.79284291400159 - 0.85373472095314 * r;","}","float snoise( vec3 v ) {","const vec2 C = vec2( 1.0 / 6.0, 1.0 / 3.0 );","const vec4 D = vec4( 0.0, 0.5, 1.0, 2.0 );","vec3 i  = floor( v + dot( v, C.yyy ) );","vec3 x0 = v - i + dot( i, C.xxx );","vec3 g = step( x0.yzx, x0.xyz );","vec3 l = 1.0 - g;","vec3 i1 = min( g.xyz, l.zxy );","vec3 i2 = max( g.xyz, l.zxy );","vec3 x1 = x0 - i1 + 1.0 * C.xxx;","vec3 x2 = x0 - i2 + 2.0 * C.xxx;","vec3 x3 = x0 - 1. + 3.0 * C.xxx;","i = mod( i, 289.0 );","vec4 p = permute( permute( permute(","i.z + vec4( 0.0, i1.z, i2.z, 1.0 ) )","+ i.y + vec4( 0.0, i1.y, i2.y, 1.0 ) )","+ i.x + vec4( 0.0, i1.x, i2.x, 1.0 ) );","float n_ = 1.0 / 7.0; // N=7","vec3 ns = n_ * D.wyz - D.xzx;","vec4 j = p - 49.0 * floor( p * ns.z *ns.z );  //  mod(p,N*N)","vec4 x_ = floor( j * ns.z );","vec4 y_ = floor( j - 7.0 * x_ );    // mod(j,N)","vec4 x = x_ *ns.x + ns.yyyy;","vec4 y = y_ *ns.x + ns.yyyy;","vec4 h = 1.0 - abs( x ) - abs( y );","vec4 b0 = vec4( x.xy, y.xy );","vec4 b1 = vec4( x.zw, y.zw );","vec4 s0 = floor( b0 ) * 2.0 + 1.0;","vec4 s1 = floor( b1 ) * 2.0 + 1.0;","vec4 sh = -step( h, vec4( 0.0 ) );","vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;","vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;","vec3 p0 = vec3( a0.xy, h.x );","vec3 p1 = vec3( a0.zw, h.y );","vec3 p2 = vec3( a1.xy, h.z );","vec3 p3 = vec3( a1.zw, h.w );","vec4 norm = taylorInvSqrt( vec4( dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3) ) );","p0 *= norm.x;","p1 *= norm.y;","p2 *= norm.z;","p3 *= norm.w;","vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3) ), 0.0 );","m = m * m;","return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),","dot(p2,x2), dot(p3,x3) ) );","}","float heightMap( vec3 coord ) {","float n = abs( snoise( coord ) );","n += 0.25   * abs( snoise( coord * 2.0 ) );","n += 0.25   * abs( snoise( coord * 4.0 ) );","n += 0.125  * abs( snoise( coord * 8.0 ) );","n += 0.0625 * abs( snoise( coord * 16.0 ) );","return n;","}","void main( void ) {","float n = heightMap( vec3(vUv.x, vUv.y, 0.0) );","vec2 disto = vec2(n,n) * bias;","vec3 c = texture2D(textureIn, vUv+disto).xyz;","gl_FragColor = vec4(c, 1.0);","}"].join("\n")};PP.lib.shader.shaders.kaleidoscope={info:{name:"kaleidoscope",author:"iq",link:"http://www.iquilezles.org"},uniforms:{textureIn:{type:"t",value:0,texture:null},resolution:{type:"v2",value:new THREE.Vector2(PP.config.dimension.width,PP.config.dimension.height)},time:{type:"f",value:0},speed:{type:"f",value:0.01}},controls:{speed:{min:0,max:10,step:0.001}},vertexShader:PP.lib.vextexShaderBase.join("\n"),update:function(a){a.material.uniforms.time.value+=this.material.uniforms.speed.value},fragmentShader:["varying vec2 vUv;","uniform float time;","uniform vec2 resolution;","uniform sampler2D textureIn;","void main(){","vec2 p = -1.0 + 2.0 * vUv.xy / resolution.xy;","vec2 muv;","float a = atan(p.y,p.x);","float r = sqrt(dot(p,p));","muv.x =          7.0*a/3.1416;","muv.y = -time+ sin(7.0*r+time) + .7*cos(time+7.0*a);","float w = .5+.5*(sin(time+7.0*r)+ .7*cos(time+7.0*a));","vec3 color = texture2D(textureIn, muv*.5).xyz;","gl_FragColor = vec4(color*w,1.0);","}"].join("\n")};PP.lib.shader.shaders.wiggle={info:{name:"wiggle",author:"Petri Wilhelmsen, @petriw",link:"http://digitalerr0r.wordpress.com/2009/04/22/xna-shader-programming-tutorial-9-post-process-wiggle/"},uniforms:{textureIn:{type:"t",value:0,texture:null},waveX:{type:"f",value:0.1},waveY:{type:"f",value:0.1},time:{type:"f",value:0},speed:{type:"f",value:0.05}},controls:{waveX:{min:0,max:0.2,step:0.001},waveY:{min:0,max:0.2,step:0.001},speed:{min:0,max:0.1,step:0.001}},vertexShader:PP.lib.vextexShaderBase.join("\n"),update:function(a){a.material.uniforms.time.value+=this.material.uniforms.speed.value},fragmentShader:["varying vec2 vUv;","uniform float time;","uniform float waveX;","uniform float waveY;","uniform sampler2D textureIn;","void main(){","vec2 tex = vUv;","tex.x += sin(time+tex.x*10.0)*waveX;","tex.y += cos(time+tex.y*10.0)*waveY;","vec3 color = texture2D(textureIn, tex).xyz;","gl_FragColor = vec4(color,1.0);","}"].join("\n")};PP.lib.shader.shaders.rgbWiggle={info:{name:"rvb wiggle",author:"@bartekd",link:"http://www.everyday3d.com/j3d/demo/009_BasicFilter.html"},uniforms:{textureIn:{type:"t",value:0,texture:null},time:{type:"f",value:0},waveR:{type:"f",value:0.5},waveG:{type:"f",value:1},waveB:{type:"f",value:1.5},speed:{type:"f",value:0.01},amplitude:{type:"f",value:0.02}},controls:{waveR:{min:0,max:2,step:0.01},waveG:{min:0,max:2,step:0.01},waveB:{min:0,max:2,step:0.01},speed:{min:0,max:0.1,step:0.001},amplitude:{min:0,max:1,step:0.001}},vertexShader:PP.lib.vextexShaderBase.join("\n"),update:function(a){a.material.uniforms.time.value+=this.material.uniforms.speed.value},fragmentShader:["varying vec2 vUv;","uniform float time;","uniform float waveR;","uniform float waveG;","uniform float waveB;","uniform float amplitude;","uniform sampler2D textureIn;","void main() {","float m1 = sin(time * 3.0 + vUv.y * 16.0) * cos(time * 2.0 + vUv.x * 10.0) * amplitude;","vec4 a = texture2D(textureIn, vUv + m1 * waveR);","vec4 b = texture2D(textureIn, vUv + m1 * waveG);","vec4 c = texture2D(textureIn, vUv + m1 * waveB);","gl_FragColor = vec4(a.r, b.g, c.b, 1.0);","}"].join("\n")};PP.lib.shader.shaders.tunnel={info:{name:"tunnel",author:"mrDoob, @mrdoob",link:"http://www.mrdoob.com"},uniforms:{textureIn:{type:"t",value:0,texture:null},time:{type:"f",value:0},resolution:{type:"v2",value:new THREE.Vector2(PP.config.dimension.width,PP.config.dimension.height)},speed:{type:"f",value:0.01}},controls:{speed:{min:0,max:0.1,step:0.001}},vertexShader:PP.lib.vextexShaderBase.join("\n"),update:function(a){a.material.uniforms.time.value+=this.material.uniforms.speed.value},fragmentShader:["uniform float time;","uniform vec2 resolution;","uniform sampler2D textureIn;","void main() {","vec2 position = - 1.0 + 2.0 * gl_FragCoord.xy / resolution.xy;","float a = atan( position.y, position.x );","float r = sqrt( dot( position, position ) );","vec2 uv;","uv.x = cos( a ) / r;","uv.y = sin( a ) / r;","uv /= 10.0;","uv += time * 0.05;","vec3 color = texture2D( textureIn, uv ).rgb;","gl_FragColor = vec4( color * r * 1.5, 1.0 );","}"].join("\n")};PP.lib.shader.shaders.ssao={info:{name:"SSAO",author:"ArKano22",link:"http://www.gamedev.net/topic/556187-the-best-ssao-ive-seen/"},uniforms:{textureIn:{type:"t",value:0,texture:null},tDepth:{type:"t",value:1,texture:null},tNormals:{type:"t",value:2,texture:null},tRandom:{type:"t",value:3,texture:THREE.ImageUtils.loadTexture("asset/img/random.png")}},vertexShader:["varying mat3 projectionMatrixInverse;","varying vec2 vUv;","void main() {","//projectionMatrixInverse = mat3( projectionMatrix[0].xyz - 1.0, projectionMatrix[1].xyz - 1.0, projectionMatrix[2].xyz - 1.0 );","projectionMatrixInverse = normalMatrix;","vUv = vec2( uv.x, 1.0 - uv.y );","gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["varying vec2 vUv;","varying mat3 projectionMatrixInverse;","uniform sampler2D tNormal;","uniform sampler2D tDepth;","uniform sampler2D textureIn;","uniform sampler2D tRandom;","vec3 readNormal( in vec2 coord) {","return normalize(texture2D(tNormal, coord).xyz * 2.0 - 1.0);","}","vec3 posFromDepth(vec2 coord) {","float d = texture2D(tDepth, coord).r;","vec3 tray = mat3(projectionMatrixInverse) * vec3((coord.x - 0.5) * 2.0, (coord.y - 0.5) * 2.0, 1.0);","return tray * d;","}","float aoFF( in vec3 ddiff, in vec3 cnorm, in float c1, in float c2) {","vec3 vv = normalize(ddiff);","float rd = length(ddiff);","return (1.0 - clamp(dot(readNormal(vUv + vec2(c1, c2)), -vv), 0.0, 1.0)) * clamp(dot(cnorm, vv), 0.0, 1.0) * (1.0 - 1.0 / sqrt(1.0 / (rd * rd) + 1.0));","} ","float giFF( in vec3 ddiff, in vec3 cnorm, in float c1, in float c2) {","vec3 vv = normalize(ddiff);","float rd = length(ddiff);","return 1.0 * clamp(dot(readNormal(vUv + vec2(c1, c2)), -vv), 0.0, 1.0) * clamp(dot(cnorm, vv), 0.0, 1.0) / (rd * rd + 1.0);","}","void main() {","vec3 n = readNormal(vUv.st);","vec3 p = posFromDepth(vUv.st);","vec3 col = texture2D(textureIn, vUv).rgb;","vec2 fres = vec2(800.0 / 128.0 * 5.0, 600.0 / 128.0 * 5.0);","vec3 random = texture2D(tRandom, vUv.st * fres.xy).rgb;","random = random * 2.0 - vec3(1.0);","float ao = 0.0;","vec3 gi = vec3(0.0,0.0,0.0);","float incx = 1.0/800.0*0.1;","float incy = 1.0/600.0*0.1;","float pw = incx;","float ph = incy;","float cdepth = texture2D(tDepth, vUv).r;","for (float i = 0.0; i < 3.0; ++i) {","float npw = (pw + 0.0007 * random.x) / cdepth;","float nph = (ph + 0.0007 * random.y) / cdepth;","vec3 ddiff = posFromDepth(vUv.st + vec2(npw, nph)) - p;","vec3 ddiff2 = posFromDepth(vUv.st + vec2(npw, -nph)) - p;","vec3 ddiff3 = posFromDepth(vUv.st + vec2(-npw, nph)) - p;","vec3 ddiff4 = posFromDepth(vUv.st + vec2(-npw, -nph)) - p;","vec3 ddiff5 = posFromDepth(vUv.st + vec2(0, nph)) - p;","vec3 ddiff6 = posFromDepth(vUv.st + vec2(0, -nph)) - p;","vec3 ddiff7 = posFromDepth(vUv.st + vec2(npw, 0)) - p;","vec3 ddiff8 = posFromDepth(vUv.st + vec2(-npw, 0)) - p;","ao += aoFF(ddiff, n, npw, nph);","ao += aoFF(ddiff2, n, npw, -nph);","ao += aoFF(ddiff3, n, -npw, nph);","ao += aoFF(ddiff4, n, -npw, -nph);","ao += aoFF(ddiff5, n, 0.0, nph);","ao += aoFF(ddiff6, n, 0.0, -nph);","ao += aoFF(ddiff7, n, npw, 0.0);","ao += aoFF(ddiff8, n, -npw, 0.0);","gi += giFF(ddiff, n, npw, nph) * texture2D(textureIn, vUv + vec2(npw, nph)).rgb;","gi += giFF(ddiff2, n, npw, -nph) * texture2D(textureIn, vUv + vec2(npw, -nph)).rgb;","gi += giFF(ddiff3, n, -npw, nph) * texture2D(textureIn, vUv + vec2(-npw, nph)).rgb;","gi += giFF(ddiff4, n, -npw, -nph) * texture2D(textureIn, vUv + vec2(-npw, -nph)).rgb;","gi += giFF(ddiff5, n, 0.0, nph) * texture2D(textureIn, vUv + vec2(0.0, nph)).rgb;","gi += giFF(ddiff6, n, 0.0, -nph) * texture2D(textureIn, vUv + vec2(0.0, -nph)).rgb;","gi += giFF(ddiff7, n, npw, 0.0) * texture2D(textureIn, vUv + vec2(npw, 0.0)).rgb;","gi += giFF(ddiff8, n, -npw, 0.0) * texture2D(textureIn, vUv + vec2(-npw, 0.0)).rgb;","pw += incx;","ph += incy;","}","ao/=24.0;","gi/=24.0;","gl_FragColor = vec4(col-vec3(ao)+gi*5.0,1.0);","}"].join("\n")};PP.lib.shader.shaders.bokeh={info:{name:"Depth-of-field shader with bokeh",author:"Altered Qualia, ported from GLSL shader by Martins Upitis",link:"http://artmartinsh.blogspot.com/2010/02/glsl-lens-blur-filter-with-bokeh.html"},uniforms:{textureIn:{type:"t",value:0,texture:null},tDepth:{type:"t",value:1,texture:null},focus:{type:"f",value:1},aspect:{type:"f",value:PP.config.dimension.width/PP.config.dimension.height},aperture:{type:"f",value:0.025},maxblur:{type:"f",value:1}},controls:{focus:{start:1,min:0,max:2,step:0.2},aperture:{start:0.025,min:0,max:0.5,step:0.01},maxblur:{start:1,min:0,max:5,step:0.5}},vertexShader:PP.lib.vextexShaderBase.join("\n"),fragmentShader:["varying vec2 vUv;","uniform sampler2D textureIn;","uniform sampler2D tDepth;","uniform float maxblur;","uniform float aperture;","uniform float focus;","uniform float aspect;","void main() {","vec2 aspectcorrect = vec2( 1.0, aspect );","vec4 depth1 = texture2D( tDepth, vUv );","float factor = depth1.x - focus;","vec2 dofblur = vec2 ( clamp( factor * aperture, -maxblur, maxblur ) );","vec2 dofblur9 = dofblur * 0.9;","vec2 dofblur7 = dofblur * 0.7;","vec2 dofblur4 = dofblur * 0.4;","vec4 col = vec4( 0.0 );","col += texture2D( textureIn, vUv.xy );","col += texture2D( textureIn, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur );","col += texture2D( textureIn, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur );","col += texture2D( textureIn, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur );","col += texture2D( textureIn, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur );","col += texture2D( textureIn, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur );","col += texture2D( textureIn, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur );","col += texture2D( textureIn, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur );","col += texture2D( textureIn, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur );","col += texture2D( textureIn, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur );","col += texture2D( textureIn, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur );","col += texture2D( textureIn, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur );","col += texture2D( textureIn, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur );","col += texture2D( textureIn, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur );","col += texture2D( textureIn, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur );","col += texture2D( textureIn, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur );","col += texture2D( textureIn, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur );","col += texture2D( textureIn, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur9 );","col += texture2D( textureIn, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur9 );","col += texture2D( textureIn, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur9 );","col += texture2D( textureIn, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur9 );","col += texture2D( textureIn, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur9 );","col += texture2D( textureIn, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur9 );","col += texture2D( textureIn, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur9 );","col += texture2D( textureIn, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur9 );","col += texture2D( textureIn, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur7 );","col += texture2D( textureIn, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur7 );","col += texture2D( textureIn, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur7 );","col += texture2D( textureIn, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur7 );","col += texture2D( textureIn, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur7 );","col += texture2D( textureIn, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur7 );","col += texture2D( textureIn, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur7 );","col += texture2D( textureIn, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur7 );","col += texture2D( textureIn, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur4 );","col += texture2D( textureIn, vUv.xy + ( vec2(  0.4,   0.0  ) * aspectcorrect ) * dofblur4 );","col += texture2D( textureIn, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur4 );","col += texture2D( textureIn, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur4 );","col += texture2D( textureIn, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur4 );","col += texture2D( textureIn, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur4 );","col += texture2D( textureIn, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur4 );","col += texture2D( textureIn, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur4 );","gl_FragColor = col / 41.0;","gl_FragColor.a = 1.0;","}"].join("\n")};PP.lib.shader.shaders.unsharpMasking={info:{name:"unsharp masking",author:"ported by thierry tranchina aka @rDad",link:"http://graphics.uni-konstanz.de/publikationen/2006/unsharp_masking/webseite/"},uniforms:{tDepth:{type:"t",value:2,texture:null},tBlur:{type:"t",value:1,texture:null},textureIn:{type:"t",value:0,texture:null},bias:{type:"f",value:-1}},controls:{bias:{min:-10,max:10,step:0.5}},vertexShader:PP.lib.vextexShaderBase.join("\n"),fragmentShader:["varying vec2 vUv;","uniform float bias;","uniform sampler2D tDepth;","uniform sampler2D tBlur;","uniform sampler2D textureIn;","void main() {","vec4 tex_depth = texture2D( tDepth, vUv );","vec4 tex_blur  = texture2D( tBlur, vUv );","vec4 tex_color = texture2D( textureIn, vUv );","vec3 spatial_imp = tex_blur.rgb - tex_depth.rgb;","vec3 final = tex_color.rgb;","if(spatial_imp.r>0.0)","{","final += spatial_imp * bias;","}","gl_FragColor = vec4(final, 1.0);","}",].join("\n")};PP.debug=PP.debug||{enabled:false,debugObject:null,debugOffset:{x:0,y:0},nbSprite:0,console:null};PP.debug.init=function(){var b,a;if(PP.gui.enabled){b={showTexture:false,showConsole:false,exportSettings:false};PP.gui.handler.add(b,"showTexture").name("show debug texture").onChange(PP.debug.showTexture);PP.gui.handler.add(b,"showConsole").name("show console").onChange(PP.debug.showConsole);PP.gui.handler.add(b,"exportSettings").name("export settings").onChange(PP.debug.exportSettings);this.debugObject=new THREE.Object3D();PP.contextFinal.scene.addObject(this.debugObject);a=new THREE.Mesh(new THREE.PlaneGeometry(PP.config.dimension.width,PP.config.dimension.height),new THREE.MeshBasicMaterial({color:10066329}));a.position.z=-470;a.visible=false;this.debugObject.addChild(a)}this.console=document.createElement("div");this.console.setAttribute("style","display:none; position:fixed; padding:5px; width:300px; height:400px; overflow:auto; background-color:#333333; font-size:12px; font-family:Arial; left:0px; bottom:0px; color:#ccc; text-align:left; z-index:1000");this.console.setAttribute("id","debug_console");document.body.appendChild(this.console)};PP.debug.addSprite=function(c){var d,a,b;d={width:PP.config.dimension.width/4,height:PP.config.dimension.height/4};a=new THREE.MeshBasicMaterial({map:c.textureOut});b=new THREE.PlaneGeometry(1,1);c.debug=new THREE.Mesh(b,a);c.debug.scale.set(d.width,d.height,1);if(this.nbSprite==0){c.debug.doubleSided=true;c.debug.scale.y=-c.debug.scale.y}c.debug.position.z=-450;c.debug.position.x=-(PP.config.dimension.width/3)+(this.debugOffset.x*(d.width+20));c.debug.position.y=(PP.config.dimension.height/3)-(this.debugOffset.y*(d.height+20));this.debugObject.addChild(c.debug);this.debugOffset.x++;if(this.debugOffset.x>2){this.debugOffset.x=0;this.debugOffset.y++}this.nbSprite++};PP.debug.update=function(){if(this.enabled){var b;for(var a in PP.list){b=PP.list[a];if(b.debug){if(b.type!==PP.TEXTURE){b.debug.materials=[b.material]}else{b.debug.materials[0].map=b.textureOut}}}THREE.SceneUtils.traverseHierarchy(this.debugObject,function(c){c.visible=true})}else{THREE.SceneUtils.traverseHierarchy(this.debugObject,function(c){c.visible=false})}};PP.debug.showTexture=function(a){PP.debug.enabled=a};PP.debug.showConsole=function(a){var b=document.getElementById("debug_console").style.display;b=(b=="none")?"block":"none";document.getElementById("debug_console").style.display=b};PP.debug.exportSettings=function(){var m="Settings:\n",h=DAT.GUI.allControllers,f=h.length,d={},a,j,g,e,b,k,c;for(e=0;e<f;e++){if(h[e].type=="number"){a=h[e].propertyName;j=h[e].object[a];g=h[e].object.effect.name;if(typeof d[g]=="undefined"){d[g]={}}d[g][a]=j}}for(b in d){c=".loadShader('"+b+"',{";for(k in d[b]){c+=k+":"+d[b][k]+", "}c=c.slice(0,-2);c+="})\n";m+=c}PP.debug.toConsole(m);PP.debug.showConsole(true)};PP.debug.toConsole=function(b){var a=document.createElement("p");a.appendChild(document.createTextNode(b));this.console.appendChild(a)};